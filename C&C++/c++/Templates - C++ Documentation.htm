<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Templates - C++ Documentation</title>
<style type="text/css">.hierarchy DIV {width:100px; height:24px; text-align:center; padding-top:8px; border:black 1px solid} </style>
<link rel="shortcut icon" type="image/x-icon" href="http://www.cplusplus.com/favicon.ico">
<link rel="stylesheet" type="text/css" href="Templates%20-%20C++%20Documentation_files/main29f.css">
<script src="Templates%20-%20C++%20Documentation_files/main29f.js" type="text/javascript"></script>
<script type="text/javascript">
new LoginBox('CH_boxLogin',1);</script>
</head><body>
<div id="CH_header">
	<a href="http://www.cplusplus.com/"><img src="Templates%20-%20C++%20Documentation_files/cpp-logo.png" alt="cplusplus.com" width="198" height="75"></a>
	<div id="CH_bar">
		<b><a href="http://www.cplusplus.com/">C++</a> : <a href="http://www.cplusplus.com/doc/">Documentation</a> : <a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a> : Templates</b>
	</div>
	
	<div id="CH_searchbox">
		<form id="search" action="/search.do" method="get">
		Search: <input name="q" size="13" class="txt"> <input value="Search" class="btn" type="submit">
		</form>
	</div>
	<div id="CH_boxLogin"><div class="C_LoginBox"><form style="display: block;" name="CH_frmLogin" id="CH_frmLogin" action="/user/access.cgi" onsubmit="elCH_boxLogin.send(); return false;" method="post"><table><tbody><tr><td></td><td class="right"><b>login:</b></td><td><input name="w" value="login" type="hidden"><input name="y" value="1" type="hidden"><input name="to" value="http://www.cplusplus.com/doc/tutorial/templates/" type="hidden"><input class="txt" name="l" size="4" title="Type user name" type="text"></td><td><input class="txt" name="p" size="4" title="Type password" type="password"></td><td><input class="btn" value="sign in" type="submit"></td></tr><tr><td>sign in using:<a href="http://www.cplusplus.com/user/access.cgi?w=login&amp;y=1&amp;pr=google&amp;to=%2Fdoc%2Ftutorial%2Ftemplates%2F" title="Sign in using your google account"><img src="Templates%20-%20C++%20Documentation_files/16google.png" width="16" height="16"></a><a href="http://www.cplusplus.com/user/access.cgi?w=login&amp;y=1&amp;pr=yahoo&amp;to=%2Fdoc%2Ftutorial%2Ftemplates%2F" title="Sign in using your Yahoo! account"><img src="Templates%20-%20C++%20Documentation_files/16yahoo.png" width="16" height="16"></a></td><td colspan="4" class="right"><label for="rememberme">remember me<input class="chk" name="rememberme" id="rememberme" value="1" type="checkbox"> &nbsp; [<a href="http://www.cplusplus.com/user/access.cgi?w=signup">register</a>]</label></td></tr></tbody></table></form><div id="CH_insLogin"></div></div></div>
</div>
<div id="CH_container">
<table id="CH_containertbl"><tbody><tr>
<td id="CH_nav">
<table class="box">
<thead>
<tr><th><a href="http://www.cplusplus.com/">cplusplus.com</a></th></tr>
</thead>
<tbody>
<tr><td class="folder"><a href="http://www.cplusplus.com/info/">Information</a></td></tr>
<tr><td class="folder selected"><a href="http://www.cplusplus.com/doc/">Documentation</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/reference/">Reference</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/articles/">Articles</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/forum/">Forum</a></td></tr>
</tbody>
</table>
<table class="box">
<thead><tr><th><a href="http://www.cplusplus.com/doc/">Documentation</a></th></tr></thead>
<tbody><tr><td class="selected folder"><a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/ascii/">Ascii Codes</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/boolean/">Boolean Operations</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/hex/">Numerical Bases</a></td></tr>
</tbody>
</table>
<table class="box">
<thead><tr><th><a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a></th></tr></thead>
<tbody><tr><td class="folder">Introduction:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/introduction/">Instructions for use</a></td></tr>
<tr><td class="folder">Basics of C++:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/program_structure/">Structure of a program</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/variables/">Variables. Data Types.</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/constants/">Constants</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/operators/">Operators</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/basic_io/">Basic Input/Output</a></td></tr>
<tr><td class="folder">Control Structures:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/control/">Control Structures</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/functions/">Functions (I)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/functions2/">Functions (II)</a></td></tr>
<tr><td class="folder">Compound Data Types:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/arrays/">Arrays</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/ntcs/">Character Sequences</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/pointers/">Pointers</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/dynamic/">Dynamic Memory</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/structures/">Data Structures</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/other_data_types/">Other Data Types</a></td></tr>
<tr><td class="folder">Object Oriented Programming:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/classes/">Classes (I)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/classes2/">Classes (II)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/inheritance/">Friendship and inheritance</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/polymorphism/">Polymorphism</a></td></tr>
<tr><td class="folder">Advanced Concepts:</td></tr>
<tr><td class="selected indent"><a href="http://www.cplusplus.com/doc/tutorial/templates/">Templates</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/namespaces/">Namespaces</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/exceptions/">Exceptions</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/typecasting/">Type Casting</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/preprocessor/">Preprocessor directives</a></td></tr>
<tr><td class="folder">C++ Standard Library:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/files/">Input/Output with files</a></td></tr>
</tbody>
</table>
<div id="CH_subnav"></div>
<br>
<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
/* single square */
google_ad_slot = "7465536459";
google_ad_width = 125;
google_ad_height = 125;
//-->
</script>
<script type="text/javascript" src="Templates%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 125px; position: relative; visibility: visible; width: 125px;"><ins id="aswift_0_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 125px; position: relative; visibility: visible; width: 125px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_0" name="aswift_0" style="left: 0pt; position: absolute; top: 0pt;" width="125" frameborder="0" height="125" scrolling="no"></iframe></ins></ins>
	</td>
	<td id="CH_main">
<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
google_ad_slot = "7973859818";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="Templates%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 90px; position: relative; visibility: visible; width: 728px;"><ins id="aswift_1_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 90px; position: relative; visibility: visible; width: 728px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_1" name="aswift_1" style="left: 0pt; position: absolute; top: 0pt;" width="728" frameborder="0" height="90" scrolling="no"></iframe></ins></ins><br><div class="C_doctop">
<h1>Templates</h1>
<div class="right"></div>
</div>
<div class="docsubtop">
<div class="right"></div>
<div class="prototype"></div>
</div>
<h3>Function templates</h3>
Function templates are special functions that can operate with <i>generic types</i>.
This allows us to create a function template whose functionality can be
adapted to more than one type or class without repeating the entire
code for each type.<br>
<br>
In C++ this can be achieved using <i>template parameters</i>. A
template parameter is a special kind of parameter that can be used to
pass a type as argument: just like regular function parameters can be
used to pass values to a function, template parameters allow to pass
also types to a function. These function templates can use these
parameters as if they were any other regular type.<br>
<br>
The format for declaring function templates with type parameters is:<br>
<br>
<tt>
template &lt;class identifier&gt; function_declaration;<br>
template &lt;typename identifier&gt; function_declaration;<br>
</tt>
<br>
The only difference between both prototypes is the use of either the keyword <tt>class</tt> or the keyword <tt>typename</tt>. Its use is indistinct, since both expressions have exactly the same meaning and behave exactly the same way.<br>
<br>
For example, to create a template function that returns the greater one of two objects we could use: <br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br></tt></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> myType&gt;
myType GetMax (myType a, myType b) {
 <var>return</var> (a&gt;b?a:b);
}</code></pre></td></tr></tbody></table></div>
<br>
<br>
Here we have created a template function with <tt>myType</tt> as
its template parameter. This template parameter represents a type that
has not yet been specified, but that can be used in the template
function as if it were a regular type. As you can see, the function
template <tt>GetMax</tt> returns the greater of two parameters of this still-undefined type.<br>
<br>
To use this function template we use the following format for the function call:<br>
<br>
<tt>
function_name &lt;type&gt; (parameters);<br>
</tt>
<br>
For example, to call <tt>GetMax</tt> to compare two integer values of type <tt>int</tt> we can write: <br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br></tt></td>
<td class="source"><pre><code><var>int</var> x,y;
GetMax &lt;<var>int</var>&gt; (x,y);</code></pre></td></tr></tbody></table></div>
<br>
<br>
When the compiler encounters this call to a template function, it uses
the template to automatically generate a function replacing each
appearance of <tt>myType</tt> by the type passed as the actual template parameter (<tt>int</tt> in this case) and then calls it. This process is automatically performed by the compiler and is invisible to the programmer.<br>
<br>
Here is the entire example:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></tt></td>
<td class="source"><pre><code><cite>// function template</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
T GetMax (T a, T b) {
  T result;
  result = (a&gt;b)? a : b;
  <var>return</var> (result);
}

<var>int</var> main () {
  <var>int</var> i=5, j=6, k;
  <var>long</var> l=10, m=5, n;
  k=GetMax&lt;<var>int</var>&gt;(i,j);
  n=GetMax&lt;<var>long</var>&gt;(l,m);
  cout &lt;&lt; k &lt;&lt; endl;
  cout &lt;&lt; n &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6
10</samp></pre></td></tr></tbody></table></div>
<br>
<br>
In this case, we have used <tt>T</tt> as the template parameter name instead of <tt>myType</tt> because it is shorter and in fact is a very common template parameter name. But you can use any identifier you like.<br>
<br>
In the example above we used the function template <tt>GetMax()</tt> twice. The first time with arguments of type <tt>int</tt> and the second one with arguments of type <tt>long</tt>. The compiler has instantiated and then called each time the appropriate version of the function.<br>
<br>
As you can see, the type <tt>T</tt> is used within the <tt>GetMax()</tt> template function even to declare new objects of that type: <br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>T result;</code></pre></td></tr></tbody></table></div>
<br>
<br>
Therefore, <tt>result</tt> will be an object of the same type as the parameters <tt>a</tt> and <tt>b</tt> when the function template is instantiated with a specific type.<br>
<br>
In this specific case where the generic type <tt>T</tt> is used as a parameter for <tt>GetMax</tt>
the compiler can find out automatically which data type has to
instantiate without having to explicitly specify it within angle
brackets (like we have done before specifying <tt>&lt;int&gt;</tt> and <tt>&lt;long&gt;</tt>). So we could have written instead:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br></tt></td>
<td class="source"><pre><code><var>int</var> i,j;
GetMax (i,j);</code></pre></td></tr></tbody></table></div>
<br>
<br>
Since both <tt>i</tt> and <tt>j</tt> are of type <tt>int</tt>, and the compiler can automatically find out that the template parameter can only be <tt>int</tt>. This implicit method produces exactly the same result:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></tt></td>
<td class="source"><pre><code><cite>// function template II</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
T GetMax (T a, T b) {
  <var>return</var> (a&gt;b?a:b);
}

<var>int</var> main () {
  <var>int</var> i=5, j=6, k;
  <var>long</var> l=10, m=5, n;
  k=GetMax(i,j);
  n=GetMax(l,m);
  cout &lt;&lt; k &lt;&lt; endl;
  cout &lt;&lt; n &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6
10</samp></pre></td></tr></tbody></table></div>
<br>
<br>
Notice how in this case, we called our function template <tt>GetMax()</tt> without explicitly specifying the type between angle-brackets <tt>&lt;&gt;</tt>. The compiler automatically determines what type is needed on each call.<br>
<br>
Because our template function includes only one template parameter (<tt>class T</tt>) and the function template itself accepts two parameters, both of this <tt>T</tt> type, we cannot call our function template with two objects of different types as arguments:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br></tt></td>
<td class="source"><pre><code><var>int</var> i;
<var>long</var> l;
k = GetMax (i,l); </code></pre></td></tr></tbody></table></div>
<br>
<br>
This would not be correct, since our <tt>GetMax</tt> function template expects two arguments of the same type, and in this call to it we use objects of two different types.<br>
<br>
We can also define function templates that accept more than one type
parameter, simply by specifying more template parameters between the
angle brackets. For example:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br></tt></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T, <var>class</var> U&gt;
T GetMin (T a, U b) {
  <var>return</var> (a&lt;b?a:b);
}</code></pre></td></tr></tbody></table></div>
<br>
<br>
In this case, our function template <tt>GetMin()</tt> accepts two parameters of different types and returns an object of the same type as the first parameter (<tt>T</tt>) that is passed. For example, after that declaration we could call <tt>GetMin()</tt> with:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br></tt></td>
<td class="source"><pre><code><var>int</var> i,j;
<var>long</var> l;
i = GetMin&lt;<var>int</var>,<var>long</var>&gt; (j,l);</code></pre></td></tr></tbody></table></div>
<br>
<br>
or simply:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>i = GetMin (j,l);</code></pre></td></tr></tbody></table></div>
<br>
<br>
even though <tt>j</tt> and <tt>l</tt> have different types, since the compiler can determine the appropriate instantiation anyway.<br>
<br>
<h3>Class templates</h3>
We also have the possibility to write class templates, so that a class
can have members that use template parameters as types. For example: <br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></tt></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mypair {
    T values [2];
  <var>public</var>:
    mypair (T first, T second)
    {
      values[0]=first; values[1]=second;
    }
};</code></pre></td></tr></tbody></table></div>
<br>
<br>
The class that we have just defined serves to store two elements of any
valid type. For example, if we wanted to declare an object of this
class to store two integer values of type <tt>int</tt> with the values 115 and 36 we would write:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>mypair&lt;<var>int</var>&gt; myobject (115, 36); </code></pre></td></tr></tbody></table></div>
<br>
<br>
this same class would also be used to create an object to store any other type:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>mypair&lt;<var>double</var>&gt; myfloats (3.0, 2.18); </code></pre></td></tr></tbody></table></div>
<br>
<br>
The only member function in the previous class template has been
defined inline within the class declaration itself. In case that we
define a function member outside the declaration of the class template,
we must always precede that definition with the <tt>template &lt;...&gt;</tt> prefix:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br></tt></td>
<td class="source"><pre><code><cite>// class templates</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mypair {
    T a, b;
  <var>public</var>:
    mypair (T first, T second)
      {a=first; b=second;}
    T getmax ();
};

<var>template</var> &lt;<var>class</var> T&gt;
T mypair&lt;T&gt;::getmax ()
{
  T retval;
  retval = a&gt;b? a : b;
  <var>return</var> retval;
}

<var>int</var> main () {
  mypair &lt;<var>int</var>&gt; myobject (100, 75);
  cout &lt;&lt; myobject.getmax();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>100</samp></pre></td></tr></tbody></table></div>
<br>
<br>
Notice the syntax of the definition of member function getmax:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br></tt></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt;
T mypair&lt;T&gt;::getmax () </code></pre></td></tr></tbody></table></div>
<br>
<br>
Confused by so many <tt>T</tt>'s? There are three <tt>T</tt>'s in this declaration: The first one is the template parameter. The second <tt>T</tt> refers to the type returned by the function. And the third <tt>T</tt>
(the one between angle brackets) is also a requirement: It specifies
that this function's template parameter is also the class template
parameter.<br>
<br>
<h3>Template specialization</h3>
If we want to define a different implementation for a template when a
specific type is passed as template parameter, we can declare a
specialization of that template.<br>
<br>
For example, let's suppose that we have a very simple class called <tt>mycontainer</tt> that can store one element of any type and that it has just one member function called <tt>increase</tt>, which increases its value. But we find that when it stores an element of type <tt>char</tt> it would be more convenient to have a completely different implementation with a function member <tt>uppercase</tt>, so we decide to declare a class template specialization for that type:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br></tt></td>
<td class="source"><pre><code><cite>// template specialization</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<cite>// class template:</cite>
<var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mycontainer {
    T element;
  <var>public</var>:
    mycontainer (T arg) {element=arg;}
    T increase () {<var>return</var> ++element;}
};

<cite>// class template specialization:</cite>
<var>template</var> &lt;&gt;
<var>class</var> mycontainer &lt;<var>char</var>&gt; {
    <var>char</var> element;
  <var>public</var>:
    mycontainer (<var>char</var> arg) {element=arg;}
    <var>char</var> uppercase ()
    {
      <var>if</var> ((element&gt;=<kbd>'a'</kbd>)&amp;&amp;(element&lt;=<kbd>'z'</kbd>))
      element+=<kbd>'A'</kbd>-<kbd>'a'</kbd>;
      <var>return</var> element;
    }
};

<var>int</var> main () {
  mycontainer&lt;<var>int</var>&gt; myint (7);
  mycontainer&lt;<var>char</var>&gt; mychar (<kbd>'j'</kbd>);
  cout &lt;&lt; myint.increase() &lt;&lt; endl;
  cout &lt;&lt; mychar.uppercase() &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>8
J</samp></pre></td></tr></tbody></table></div>
<br>
<br>
This is the syntax used in the class template specialization:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code><var>template</var> &lt;&gt; <var>class</var> mycontainer &lt;<var>char</var>&gt; { ... };</code></pre></td></tr></tbody></table></div>
<br>
<br>
First of all, notice that we precede the class template name with an empty <tt>template&lt;&gt;</tt> parameter list. This is to explicitly declare it as a template specialization.<br>
<br>
But more important than this prefix, is the <tt>&lt;char&gt;</tt>
specialization parameter after the class template name. This
specialization parameter itself identifies the type for which we are
going to declare a template class specialization (<tt>char</tt>). Notice the differences between the generic class template and the specialization:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br></tt></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt; <var>class</var> mycontainer { ... };
<var>template</var> &lt;&gt; <var>class</var> mycontainer &lt;<var>char</var>&gt; { ... };</code></pre></td></tr></tbody></table></div>
<br>
<br>
The first line is the generic template, and the second one is the specialization.<br>
<br>
When we declare specializations for a template class, we must also
define all its members, even those exactly equal to the generic
template class, because there is no "inheritance" of members from the
generic template to the specialization.<br>
<br>
<h3>Non-type parameters for templates</h3>
Besides the template arguments that are preceded by the <tt>class</tt> or <tt>typename</tt>
keywords , which represent types, templates can also have regular typed
parameters, similar to those found in functions. As an example, have a
look at this class template that is used to contain sequences of
elements:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br></tt></td>
<td class="source"><pre><code><cite>// sequence template</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T, <var>int</var> N&gt;
<var>class</var> mysequence {
    T memblock [N];
  <var>public</var>:
    <var>void</var> setmember (<var>int</var> x, T value);
    T getmember (<var>int</var> x);
};

<var>template</var> &lt;<var>class</var> T, <var>int</var> N&gt;
<var>void</var> mysequence&lt;T,N&gt;::setmember (<var>int</var> x, T value) {
  memblock[x]=value;
}

<var>template</var> &lt;<var>class</var> T, <var>int</var> N&gt;
T mysequence&lt;T,N&gt;::getmember (<var>int</var> x) {
  <var>return</var> memblock[x];
}

<var>int</var> main () {
  mysequence &lt;<var>int</var>,5&gt; myints;
  mysequence &lt;<var>double</var>,5&gt; myfloats;
  myints.setmember (0,100);
  myfloats.setmember (3,3.1416);
  cout &lt;&lt; myints.getmember(0) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; myfloats.getmember(3) &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>100
3.1416 </samp></pre></td></tr></tbody></table></div>
<br>
<br>
It is also possible to set default values or types for class template
parameters. For example, if the previous class template definition had
been:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T=<var>char</var>, <var>int</var> N=10&gt; <var>class</var> mysequence {..};</code></pre></td></tr></tbody></table></div>
<br>
<br>
We could create objects using the default template parameters by declaring:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>mysequence&lt;&gt; myseq;</code></pre></td></tr></tbody></table></div>
<br>
<br>
Which would be equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>mysequence&lt;<var>char</var>,10&gt; myseq;</code></pre></td></tr></tbody></table></div>
<br>
<br>
<h3>Templates and multiple-file projects</h3>
From the point of view of the compiler, templates are not normal
functions or classes. They are compiled on demand, meaning that the
code of a template function is not compiled until an instantiation with
specific template arguments is required. At that moment, when an
instantiation is required, the compiler generates a function
specifically for those arguments from the template.<br>
<br>
When projects grow it is usual to split the code of a program in
different source code files. In these cases, the interface and
implementation are generally separated. Taking a library of functions
as example, the interface generally consists of declarations of the
prototypes of all the functions that can be called. These are generally
declared in a "header file" with a .h extension, and the implementation
(the definition of these functions) is in an independent file with c++
code.<br>
<br>
Because templates are compiled when required, this forces a restriction
for multi-file projects: the implementation (definition) of a template
class or function must be in the same file as its declaration. That
means that we cannot separate the interface in a separate header file,
and that we must include both interface and implementation in any file
that uses the templates.<br>
<br>
Since no code is generated until a template is instantiated when
required, compilers are prepared to allow the inclusion more than once
of the same template file with both declarations and definitions in a
project without generating linkage errors.<br>
<table class="C_docPrevNext"><tbody><tr><td class="prev"><a href="http://www.cplusplus.com/doc/tutorial/polymorphism/" rel="prev"><img src="Templates%20-%20C++%20Documentation_files/navigate_previous.gif" alt="Previous">Previous:<br><b>Polymorphism</b></a></td><td class="index"><a href="http://www.cplusplus.com/doc/tutorial/" rel="index"><img src="Templates%20-%20C++%20Documentation_files/navigate_index.gif" alt="Index">Index</a></td><td class="next"><a href="http://www.cplusplus.com/doc/tutorial/namespaces/" rel="next"><img src="Templates%20-%20C++%20Documentation_files/navigate_next.gif" alt="Next">Next:<br><b>Namespaces</b></a></td></tr></tbody></table><div id="CH_bb"></div><script type="text/javascript">new doc_Page('CH_bb','/doc/item.cgi',19,0,0,32768);</script>
<p>

<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
google_ad_slot = "7973859818";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="Templates%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 90px; position: relative; visibility: visible; width: 728px;"><ins id="aswift_2_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 90px; position: relative; visibility: visible; width: 728px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_2" name="aswift_2" style="left: 0pt; position: absolute; top: 0pt;" width="728" frameborder="0" height="90" scrolling="no"></iframe></ins></ins>
</p></td></tr></tbody></table>
</div>
<div id="CH_footer">
	<a href="http://www.cplusplus.com/">Home page</a> | <a href="http://www.cplusplus.com/privacy.do">Privacy policy</a><br>© cplusplus.com, 2000-2011 - All rights reserved - <i>v2.9</i><br><a href="http://www.cplusplus.com/contact.do?referrer=http%3A%2F%2Fwww.cplusplus.com%2Fdoc%2Ftutorial%2Ftemplates%2F">Spotted an error? contact us</a>
</div>

<script src="Templates%20-%20C++%20Documentation_files/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
onPrint.print();
var gso = new Session ('ssn29','rel29',14400,86400,1313153111);
_uacct = "UA-521783-1";
urchinTracker();
</script>
</body></html>