<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Input/Output with files - C++ Documentation</title>
<style type="text/css">.hierarchy DIV {width:100px; height:24px; text-align:center; padding-top:8px; border:black 1px solid} </style>
<link rel="shortcut icon" type="image/x-icon" href="http://www.cplusplus.com/favicon.ico">
<link rel="stylesheet" type="text/css" href="Input_Output%20with%20files%20-%20C++%20Documentation_files/main29f.css">
<script src="Input_Output%20with%20files%20-%20C++%20Documentation_files/main29f.js" type="text/javascript"></script>
<script type="text/javascript">
new LoginBox('CH_boxLogin',1);</script>
</head><body>
<div id="CH_header">
	<a href="http://www.cplusplus.com/"><img src="Input_Output%20with%20files%20-%20C++%20Documentation_files/cpp-logo.png" alt="cplusplus.com" width="198" height="75"></a>
	<div id="CH_bar">
		<b><a href="http://www.cplusplus.com/">C++</a> : <a href="http://www.cplusplus.com/doc/">Documentation</a> : <a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a> : Input/Output with files</b>
	</div>
	
	<div id="CH_searchbox">
		<form id="search" action="/search.do" method="get">
		Search: <input name="q" size="13" class="txt"> <input value="Search" class="btn" type="submit">
		</form>
	</div>
	<div id="CH_boxLogin"><div class="loginmessage">&nbsp;<img src="Input_Output%20with%20files%20-%20C++%20Documentation_files/waitblue.gif"></div>
	</div>
</div>
<div id="CH_container">
<table id="CH_containertbl"><tbody><tr>
<td id="CH_nav">
<table class="box">
<thead>
<tr><th><a href="http://www.cplusplus.com/">cplusplus.com</a></th></tr>
</thead>
<tbody>
<tr><td class="folder"><a href="http://www.cplusplus.com/info/">Information</a></td></tr>
<tr><td class="folder selected"><a href="http://www.cplusplus.com/doc/">Documentation</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/reference/">Reference</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/articles/">Articles</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/forum/">Forum</a></td></tr>
</tbody>
</table>
<table class="box">
<thead><tr><th><a href="http://www.cplusplus.com/doc/">Documentation</a></th></tr></thead>
<tbody><tr><td class="selected folder"><a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/ascii/">Ascii Codes</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/boolean/">Boolean Operations</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/hex/">Numerical Bases</a></td></tr>
</tbody>
</table>
<table class="box">
<thead><tr><th><a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a></th></tr></thead>
<tbody><tr><td class="folder">Introduction:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/introduction/">Instructions for use</a></td></tr>
<tr><td class="folder">Basics of C++:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/program_structure/">Structure of a program</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/variables/">Variables. Data Types.</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/constants/">Constants</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/operators/">Operators</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/basic_io/">Basic Input/Output</a></td></tr>
<tr><td class="folder">Control Structures:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/control/">Control Structures</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/functions/">Functions (I)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/functions2/">Functions (II)</a></td></tr>
<tr><td class="folder">Compound Data Types:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/arrays/">Arrays</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/ntcs/">Character Sequences</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/pointers/">Pointers</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/dynamic/">Dynamic Memory</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/structures/">Data Structures</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/other_data_types/">Other Data Types</a></td></tr>
<tr><td class="folder">Object Oriented Programming:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/classes/">Classes (I)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/classes2/">Classes (II)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/inheritance/">Friendship and inheritance</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/polymorphism/">Polymorphism</a></td></tr>
<tr><td class="folder">Advanced Concepts:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/templates/">Templates</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/namespaces/">Namespaces</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/exceptions/">Exceptions</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/typecasting/">Type Casting</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/preprocessor/">Preprocessor directives</a></td></tr>
<tr><td class="folder">C++ Standard Library:</td></tr>
<tr><td class="selected indent"><a href="http://www.cplusplus.com/doc/tutorial/files/">Input/Output with files</a></td></tr>
</tbody>
</table>
<div id="CH_subnav"></div>
<br>
<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
/* single square */
google_ad_slot = "7465536459";
google_ad_width = 125;
google_ad_height = 125;
//-->
</script>
<script type="text/javascript" src="Input_Output%20with%20files%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 125px; position: relative; visibility: visible; width: 125px;"><ins id="aswift_0_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 125px; position: relative; visibility: visible; width: 125px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_0" name="aswift_0" style="left: 0pt; position: absolute; top: 0pt;" width="125" frameborder="0" height="125" scrolling="no"></iframe></ins></ins>
	</td>
	<td id="CH_main">
<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
google_ad_slot = "7973859818";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="Input_Output%20with%20files%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 90px; position: relative; visibility: visible; width: 728px;"><ins id="aswift_1_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 90px; position: relative; visibility: visible; width: 728px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_1" name="aswift_1" style="left: 0pt; position: absolute; top: 0pt;" width="728" frameborder="0" height="90" scrolling="no"></iframe></ins></ins><br><div class="C_doctop">
<h1>Input/Output with files</h1>
<div class="right"></div>
</div>
<div class="docsubtop">
<div class="right"></div>
<div class="prototype"></div>
</div>
C++ provides the following classes to perform output and input of characters to/from files: <br>
<br>
<ul>
<li><b>ofstream:</b> Stream class to write on files</li>
<li><b>ifstream:</b> Stream class to read from files</li>
<li><b>fstream:</b> Stream class to both read and write from/to files.</li>
</ul>
<br>
These classes are derived directly or indirectly from the classes <tt>istream</tt>, and <tt>ostream</tt>. We have already used objects whose types were these classes: <tt>cin</tt> is an object of class <tt>istream</tt> and <tt>cout</tt> is an object of class <tt>ostream</tt>.
Therfore, we have already been using classes that are related to our
file streams. And in fact, we can use our file streams the same way we
are already used to use <tt>cin</tt> and <tt>cout</tt>, with the only difference that we have to associate these streams with physical files. Let's see an example:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br></tt></td>
<td class="source"><pre><code><cite>// basic file operations</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  ofstream myfile;
  myfile.open (<kbd>"example.txt"</kbd>);
  myfile &lt;&lt; <kbd>"Writing this to a file.\n"</kbd>;
  myfile.close();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>[file example.txt]
Writing this to a file.</samp></pre></td></tr></tbody></table></div>
<br>
<br>
This code creates a file called <tt>example.txt</tt> and inserts a sentence into it in the same way we are used to do with <tt>cout</tt>, but using the file stream <tt>myfile</tt> instead.<br>
<br>
But let's go step by step:<br>
<br>
<h3>Open a file</h3>
<br>
The first operation generally performed on an object of one of these
classes is to associate it to a real file. This procedure is known as
to <i>open a file</i>.
An open file is represented within a program by a stream object (an
instantiation of one of these classes, in the previous example this was
<tt>myfile</tt>) and any input or output operation performed on this stream object will be applied to the physical file associated to it.<br>
<br>
In order to open a file with a stream object we use its member function <tt>open()</tt>:<br>
<br>
<tt>
open (filename, mode);<br>
</tt>
<br>
Where <tt>filename</tt> is a null-terminated character sequence of type <tt>const char *</tt> (the same type that string literals have) representing the name of the file to be opened, and <tt>mode</tt> is an optional parameter with a combination of the following flags:<br>
<br>
<table class="boxed">
<tbody><tr><td>ios::in</td><td>Open for input operations.</td></tr>
<tr><td>ios::out</td><td>Open for output operations.</td></tr>
<tr><td>ios::binary</td><td>Open in binary mode.</td></tr>
<tr><td>ios::ate</td><td>Set the initial position at the end of the file.<br>
If this flag is not set to any value, the initial position is the beginning of the file.</td></tr>
<tr><td>ios::app</td><td>All output operations are performed at the end
of the file, appending the content to the current content of the file.
This flag can only be used in streams open for output-only operations.</td></tr>
<tr><td>ios::trunc</td><td>If the file opened for output operations already existed before, its previous content is deleted and replaced by the new one.</td></tr>
</tbody></table>
<br>
All these flags can be combined using the bitwise operator OR (<tt>|</tt>). For example, if we want to open the file <tt>example.bin</tt> in binary mode to add data we could do it by the following call to member function <tt>open()</tt>:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br></tt></td>
<td class="source"><pre><code>ofstream myfile;
myfile.open (<kbd>"example.bin"</kbd>, ios::out | ios::app | ios::binary); </code></pre></td></tr></tbody></table></div>
<br>
<br>
Each one of the <tt>open()</tt> member functions of the classes <tt>ofstream</tt>, <tt>ifstream</tt> and <tt>fstream</tt> has a default mode that is used if the file is opened without a second argument:<br>
<br>
<table class="boxed">
<tbody><tr><th>class</th><th>default mode parameter</th></tr>
<tr><td>ofstream</td><td>ios::out</td></tr>
<tr><td>ifstream</td><td>ios::in</td></tr>
<tr><td>fstream</td><td>ios::in | ios::out</td></tr>
</tbody></table>
<br>
For <tt>ifstream</tt> and <tt>ofstream</tt> classes, <tt>ios::in</tt> and <tt>ios::out</tt> are automatically and respectively assumed, even if a mode that does not include them is passed as second argument to the <tt>open()</tt> member function.<br>
<br>
The default value is only applied if the function is called without
specifying any value for the mode parameter. If the function is called
with any value in that parameter the default mode is overridden, not
combined.<br>
<br>
File streams opened in binary mode perform input and output operations
independently of any format considerations. Non-binary files are known
as <i>text files</i>, and some translations may occur due to formatting of some special characters (like newline and carriage return characters).<br>
<br>
Since the first task that is performed on a file stream object is
generally to open a file, these three classes include a constructor
that automatically calls the <tt>open()</tt> member function and has the exact same parameters as this member. Therefore, we could also have declared the previous <tt>myfile</tt> object and conducted the same opening operation in our previous example by writing:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>ofstream myfile (<kbd>"example.bin"</kbd>, ios::out | ios::app | ios::binary);</code></pre></td></tr></tbody></table></div>
<br>
<br>
Combining object construction and stream opening in a single statement. Both forms to open a file are valid and equivalent.<br>
<br>
To check if a file stream was successful opening a file, you can do it by calling to member <tt>is_open()</tt>
with no arguments. This member function returns a bool value of true in
the case that indeed the stream object is associated with an open file,
or false otherwise:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code><var>if</var> (myfile.is_open()) { <cite>/* ok, proceed with output */</cite> }</code></pre></td></tr></tbody></table></div>
<br>
<br>
<h3>Closing a file</h3>
When we are finished with our input and output operations on a file we
shall close it so that its resources become available again. In order
to do that we have to call the stream's member function <tt>close()</tt>. This member function takes no parameters, and what it does is to flush the associated buffers and close the file:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>myfile.close();</code></pre></td></tr></tbody></table></div>
<br>
<br>
Once this member function is called, the stream object can be used to
open another file, and the file is available again to be opened by
other processes.<br>
<br>
In case that an object is destructed while still associated with an
open file, the destructor automatically calls the member function <tt>close()</tt>.<br>
<br>
<h3>Text files</h3>
Text file streams are those where we do not include the <tt>ios::binary</tt>
flag in their opening mode. These files are designed to store text and
thus all values that we input or output from/to them can suffer some
formatting transformations, which do not necessarily correspond to
their literal binary value.<br>
<br>
Data output operations on text files are performed in the same way we operated with <tt>cout</tt>:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></tt></td>
<td class="source"><pre><code><cite>// writing on a text file</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  ofstream myfile (<kbd>"example.txt"</kbd>);
  <var>if</var> (myfile.is_open())
  {
    myfile &lt;&lt; <kbd>"This is a line.\n"</kbd>;
    myfile &lt;&lt; <kbd>"This is another line.\n"</kbd>;
    myfile.close();
  }
  <var>else</var> cout &lt;&lt; <kbd>"Unable to open file"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>[file example.txt]
This is a line.
This is another line.</samp></pre></td></tr></tbody></table></div>
<br>
<br>
Data input from a file can also be performed in the same way that we did with <tt>cin</tt>:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></tt></td>
<td class="source"><pre><code><cite>// reading a text file</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  string line;
  ifstream myfile (<kbd>"example.txt"</kbd>);
  <var>if</var> (myfile.is_open())
  {
    <var>while</var> ( myfile.good() )
    {
      getline (myfile,line);
      cout &lt;&lt; line &lt;&lt; endl;
    }
    myfile.close();
  }

  <var>else</var> cout &lt;&lt; <kbd>"Unable to open file"</kbd>; 

  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>This is a line.
This is another line.  </samp></pre></td></tr></tbody></table></div>
<br>
<br>
This last example reads a text file and prints out its content on the
screen. Notice how we have used a new member function, called <tt>good()</tt>
that returns true in the case that the stream is ready for input/output
operations. We have created a while loop that finishes when indeed <tt>myfile.good()</tt> is no longer true, which will happen either if the end of the file has been reached or if some other error occurred.<br>
<br>
<h3>Checking state flags</h3>
In addition to <tt>good()</tt>, which
checks whether the stream is ready for input/output operations, other
member functions exist to check for specific states of a stream (all of
them return a bool value): <br>
<br>
<dl>
<dt>bad()</dt>
<dd>Returns true if a reading or writing operation fails. For example
in the case that we try to write to a file that is not open for writing
or if the device where we try to write has no space left.</dd>
<dt>fail()</dt>
<dd>Returns true in the same cases as bad(), but also in the case that
a format error happens, like when an alphabetical character is
extracted when we are trying to read an integer number.</dd>
<dt>eof()</dt>
<dd>Returns true if a file open for reading has reached the end.</dd>
<dt>good()</dt>
<dd>It is the most generic state flag: it returns false in the same
cases in which calling any of the previous functions would return true.</dd>
</dl>
<br>
In order to reset the state flags checked by any of these member functions we have just seen we can use the member function <tt>clear()</tt>, which takes no parameters.<br>
<br>
<h3>get and put stream pointers</h3>
All i/o streams objects have, at least, one internal stream pointer:<br>
<br>
<tt>ifstream</tt>, like <tt>istream</tt>, has a pointer known as the <i>get pointer</i> that points to the element to be read in the next input operation.<br>
<br>
<tt>ofstream</tt>, like <tt>ostream</tt>, has a pointer known as the <i>put pointer</i> that points to the location where the next element has to be written.<br>
<br>
Finally, <tt>fstream</tt>, inherits both, the get and the put pointers, from <tt>iostream</tt> (which is itself derived from both <tt>istream</tt> and <tt>ostream</tt>).<br>
<br>
These internal stream pointers that point to the reading or writing
locations within a stream can be manipulated using the following member
functions: <br>
<br>
<h4>tellg() and tellp()</h4>
These two member functions have no parameters and return a value of the member type <tt>pos_type</tt>, which is an integer data type representing the current position of the get stream pointer (in the case of <tt>tellg</tt>) or the put stream pointer (in the case of <tt>tellp</tt>).<br>
<br>
<h4>seekg() and seekp()</h4>
These functions allow us to change the position of the get and put
stream pointers. Both functions are overloaded with two different
prototypes. The first prototype is:<br>
<br>
<tt>
seekg ( position );<br>
seekp ( position );<br>
</tt>
<br>
Using this prototype the stream pointer is changed to the absolute position <tt>position</tt> (counting from the beginning of the file). The type for this parameter is the same as the one returned by functions <tt>tellg</tt> and <tt>tellp</tt>: the member type <tt>pos_type</tt>, which is an integer value.<br>
<br>
The other prototype for these functions is:<br>
<br>
<tt>
seekg ( offset, direction );<br>
seekp ( offset, direction );<br>
</tt>
<br>
Using this prototype, the position of the get or put pointer is set to
an offset value relative to some specific point determined by the
parameter <tt>direction</tt>. <tt>offset</tt> is of the member type <tt>off_type</tt>, which is also an integer type. And <tt>direction</tt> is of type <tt>seekdir</tt>, which is an enumerated type (<tt>enum</tt>) that determines the point from where offset is counted from, and that can take any of the following values:<br>
<br>
<table class="boxed">
<tbody><tr><td>ios::beg</td><td>offset counted from the beginning of the stream</td></tr>
<tr><td>ios::cur</td><td>offset counted from the current position of the stream pointer</td></tr>
<tr><td>ios::end</td><td>offset counted from the end of the stream</td></tr>
</tbody></table>
<br>
The following example uses the member functions we have just seen to obtain the size of a file: <br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></tt></td>
<td class="source"><pre><code><cite>// obtaining file size</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  <var>long</var> begin,end;
  ifstream myfile (<kbd>"example.txt"</kbd>);
  begin = myfile.tellg();
  myfile.seekg (0, ios::end);
  end = myfile.tellg();
  myfile.close();
  cout &lt;&lt; <kbd>"size is: "</kbd> &lt;&lt; (end-begin) &lt;&lt; <kbd>" bytes.\n"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>size is: 40 bytes.</samp></pre></td></tr></tbody></table></div>
<br>
<br>
<h3>Binary files</h3>
In binary files, to input and output data with the extraction and insertion operators (<tt>&lt;&lt;</tt> and <tt>&gt;&gt;</tt>) and functions like <tt>getline</tt>
is not efficient, since we do not need to format any data, and data may
not use the separation codes used by text files to separate elements
(like space, newline, etc...).<br>
<br>
File streams include two member functions specifically designed to input and output binary data sequentially: <tt>write</tt> and <tt>read</tt>. The first one (<tt>write</tt>) is a member function of <tt>ostream</tt> inherited by <tt>ofstream</tt>. And <tt>read</tt> is a member function of <tt>istream</tt> that is inherited by <tt>ifstream</tt>. Objects of class <tt>fstream</tt> have both members. Their prototypes are:<br>
<br>
<tt>
write ( memory_block, size );<br>
read ( memory_block, size );<br>
</tt>
<br>
Where <tt>memory_block</tt> is of type "pointer to char" (<tt>char*</tt>),
and represents the address of an array of bytes where the read data
elements are stored or from where the data elements to be written are
taken. The <tt>size</tt> parameter is an integer value that specifies the number of characters to be read or written from/to the memory block.<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br></tt></td>
<td class="source"><pre><code><cite>// reading a complete binary file</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

ifstream::pos_type size;
<var>char</var> * memblock;

<var>int</var> main () {
  ifstream file (<kbd>"example.bin"</kbd>, ios::in|ios::binary|ios::ate);
  <var>if</var> (file.is_open())
  {
    size = file.tellg();
    memblock = <var>new</var> <var>char</var> [size];
    file.seekg (0, ios::beg);
    file.read (memblock, size);
    file.close();

    cout &lt;&lt; <kbd>"the complete file content is in memory"</kbd>;

    <var>delete</var>[] memblock;
  }
  <var>else</var> cout &lt;&lt; <kbd>"Unable to open file"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>the complete file content is in memory</samp></pre></td></tr></tbody></table></div>
<br>
<br>
In this example the entire file is read and stored in a memory block. Let's examine how this is done:<br>
<br>
First, the file is open with the <tt>ios::ate</tt> flag, which means that the get pointer will be positioned at the end of the file. This way, when we call to member <tt>tellg()</tt>, we will directly obtain the size of the file. Notice the type we have used to declare variable <tt>size</tt>:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>ifstream::pos_type size;</code></pre></td></tr></tbody></table></div>
<br>
<br>
<tt>ifstream::pos_type</tt> is a specific type used fo</td></tr></tbody></table></div></body></html>