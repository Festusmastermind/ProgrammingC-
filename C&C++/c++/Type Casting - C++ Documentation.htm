<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>


<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Type Casting - C++ Documentation</title>
<style type="text/css">.hierarchy DIV {width:100px; height:24px; text-align:center; padding-top:8px; border:black 1px solid} </style>
<link rel="shortcut icon" type="image/x-icon" href="http://www.cplusplus.com/favicon.ico">
<link rel="stylesheet" type="text/css" href="Type%20Casting%20-%20C++%20Documentation_files/main29f.css">
<script src="Type%20Casting%20-%20C++%20Documentation_files/main29f.js" type="text/javascript"></script>
<script type="text/javascript">
new LoginBox('CH_boxLogin',1);</script>
</head><body>
<div id="CH_header">
	<a href="http://www.cplusplus.com/"><img src="Type%20Casting%20-%20C++%20Documentation_files/cpp-logo.png" alt="cplusplus.com" width="198" height="75"></a>
	<div id="CH_bar">
		<b><a href="http://www.cplusplus.com/">C++</a> : <a href="http://www.cplusplus.com/doc/">Documentation</a> : <a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a> : Type Casting</b>
	</div>
	
	<div id="CH_searchbox">
		<form id="search" action="/search.do" method="get">
		Search: <input name="q" size="13" class="txt"> <input value="Search" class="btn" type="submit">
		</form>
	</div>
	<div id="CH_boxLogin"><div class="C_LoginBox"><form style="display: block;" name="CH_frmLogin" id="CH_frmLogin" action="/user/access.cgi" onsubmit="elCH_boxLogin.send(); return false;" method="post"><table><tbody><tr><td></td><td class="right"><b>login:</b></td><td><input name="w" value="login" type="hidden"><input name="y" value="1" type="hidden"><input name="to" value="http://www.cplusplus.com/doc/tutorial/typecasting/" type="hidden"><input class="txt" name="l" size="4" title="Type user name" type="text"></td><td><input class="txt" name="p" size="4" title="Type password" type="password"></td><td><input class="btn" value="sign in" type="submit"></td></tr><tr><td>sign in using:<a href="http://www.cplusplus.com/user/access.cgi?w=login&amp;y=1&amp;pr=google&amp;to=%2Fdoc%2Ftutorial%2Ftypecasting%2F" title="Sign in using your google account"><img src="Type%20Casting%20-%20C++%20Documentation_files/16google.png" width="16" height="16"></a><a href="http://www.cplusplus.com/user/access.cgi?w=login&amp;y=1&amp;pr=yahoo&amp;to=%2Fdoc%2Ftutorial%2Ftypecasting%2F" title="Sign in using your Yahoo! account"><img src="Type%20Casting%20-%20C++%20Documentation_files/16yahoo.png" width="16" height="16"></a></td><td colspan="4" class="right"><label for="rememberme">remember me<input class="chk" name="rememberme" id="rememberme" value="1" type="checkbox"> &nbsp; [<a href="http://www.cplusplus.com/user/access.cgi?w=signup">register</a>]</label></td></tr></tbody></table></form><div id="CH_insLogin"></div></div></div>
</div>
<div id="CH_container">
<table id="CH_containertbl"><tbody><tr>
<td id="CH_nav">
<table class="box">
<thead>
<tr><th><a href="http://www.cplusplus.com/">cplusplus.com</a></th></tr>
</thead>
<tbody>
<tr><td class="folder"><a href="http://www.cplusplus.com/info/">Information</a></td></tr>
<tr><td class="folder selected"><a href="http://www.cplusplus.com/doc/">Documentation</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/reference/">Reference</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/articles/">Articles</a></td></tr>
<tr><td class="folder"><a href="http://www.cplusplus.com/forum/">Forum</a></td></tr>
</tbody>
</table>
<table class="box">
<thead><tr><th><a href="http://www.cplusplus.com/doc/">Documentation</a></th></tr></thead>
<tbody><tr><td class="selected folder"><a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/ascii/">Ascii Codes</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/boolean/">Boolean Operations</a></td></tr>
<tr><td><a href="http://www.cplusplus.com/doc/hex/">Numerical Bases</a></td></tr>
</tbody>
</table>
<table class="box">
<thead><tr><th><a href="http://www.cplusplus.com/doc/tutorial/">C++ Language Tutorial</a></th></tr></thead>
<tbody><tr><td class="folder">Introduction:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/introduction/">Instructions for use</a></td></tr>
<tr><td class="folder">Basics of C++:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/program_structure/">Structure of a program</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/variables/">Variables. Data Types.</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/constants/">Constants</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/operators/">Operators</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/basic_io/">Basic Input/Output</a></td></tr>
<tr><td class="folder">Control Structures:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/control/">Control Structures</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/functions/">Functions (I)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/functions2/">Functions (II)</a></td></tr>
<tr><td class="folder">Compound Data Types:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/arrays/">Arrays</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/ntcs/">Character Sequences</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/pointers/">Pointers</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/dynamic/">Dynamic Memory</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/structures/">Data Structures</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/other_data_types/">Other Data Types</a></td></tr>
<tr><td class="folder">Object Oriented Programming:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/classes/">Classes (I)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/classes2/">Classes (II)</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/inheritance/">Friendship and inheritance</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/polymorphism/">Polymorphism</a></td></tr>
<tr><td class="folder">Advanced Concepts:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/templates/">Templates</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/namespaces/">Namespaces</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/exceptions/">Exceptions</a></td></tr>
<tr><td class="selected indent"><a href="http://www.cplusplus.com/doc/tutorial/typecasting/">Type Casting</a></td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/preprocessor/">Preprocessor directives</a></td></tr>
<tr><td class="folder">C++ Standard Library:</td></tr>
<tr><td class="indent"><a href="http://www.cplusplus.com/doc/tutorial/files/">Input/Output with files</a></td></tr>
</tbody>
</table>
<div id="CH_subnav"></div>
<br>
<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
/* single square */
google_ad_slot = "7465536459";
google_ad_width = 125;
google_ad_height = 125;
//-->
</script>
<script type="text/javascript" src="Type%20Casting%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 125px; position: relative; visibility: visible; width: 125px;"><ins id="aswift_0_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 125px; position: relative; visibility: visible; width: 125px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_0" name="aswift_0" style="left: 0pt; position: absolute; top: 0pt;" width="125" frameborder="0" height="125" scrolling="no"></iframe></ins></ins>
	</td>
	<td id="CH_main">
<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
google_ad_slot = "7973859818";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="Type%20Casting%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 90px; position: relative; visibility: visible; width: 728px;"><ins id="aswift_1_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 90px; position: relative; visibility: visible; width: 728px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_1" name="aswift_1" style="left: 0pt; position: absolute; top: 0pt;" width="728" frameborder="0" height="90" scrolling="no"></iframe></ins></ins><br><div class="C_doctop">
<h1>Type Casting</h1>
<div class="right"></div>
</div>
<div class="docsubtop">
<div class="right"></div>
<div class="prototype"></div>
</div>
Converting an expression of a given type into another type is known as <i>type-casting</i>. We have already seen some ways to type cast:<br>
<br>
<h3>Implicit conversion</h3>
Implicit conversions do not require any operator. They are
automatically performed when a value is copied to a compatible type.
For example:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br></tt></td>
<td class="source"><pre><code><var>short</var> a=2000;
<var>int</var> b;
b=a;</code></pre></td></tr></tbody></table></div>
<br>
<br>
Here, the value of <tt>a</tt> has been promoted from <tt>short</tt> to <tt>int</tt>
and we have not had to specify any type-casting operator. This is known
as a standard conversion. Standard conversions affect fundamental data
types, and allow conversions such as the conversions between numerical
types (<tt>short</tt> to <tt>int</tt>, <tt>int</tt> to <tt>float</tt>, <tt>double</tt> to <tt>int</tt>...), to or from <tt>bool</tt>,
and some pointer conversions. Some of these conversions may imply a
loss of precision, which the compiler can signal with a warning. This
can be avoided with an explicit conversion.<br>
<br>
Implicit conversions also include constructor or operator conversions,
which affect classes that include specific constructors or operator
functions to perform conversions. For example:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br></tt></td>
<td class="source"><pre><code><var>class</var> A {};
<var>class</var> B { <var>public</var>: B (A a) {} };

A a;
B b=a;</code></pre></td></tr></tbody></table></div>
<br>
<br>
Here, a implicit conversion happened between objects of <tt>class A</tt> and <tt>class B</tt>, because <tt>B</tt> has a constructor that takes an object of class <tt>A</tt> as parameter. Therefore implicit conversions from <tt>A</tt> to <tt>B</tt> are allowed.<br>
<br>
<h3>Explicit conversion</h3>
C++ is a strong-typed language. Many conversions, specially those that
imply a different interpretation of the value, require an explicit
conversion. We have already seen two notations for explicit type
conversion: functional and c-like casting:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br></tt></td>
<td class="source"><pre><code><var>short</var> a=2000;
<var>int</var> b;
b = (<var>int</var>) a;    <cite>// c-like cast notation</cite>
b = <var>int</var> (a);    <cite>// functional notation </cite></code></pre></td></tr></tbody></table></div>
<br>
<br>
The functionality of these explicit conversion operators is enough for
most needs with fundamental data types. However, these operators can be
applied indiscriminately on classes and pointers to classes, which can
lead to code that while being syntactically correct can cause runtime
errors. For example, the following code is syntactically correct: <br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></tt></td>
<td class="source"><pre><code><cite>// class type-casting</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> CDummy {
    <var>float</var> i,j;
};

<var>class</var> CAddition {
	<var>int</var> x,y;
  <var>public</var>:
	CAddition (<var>int</var> a, <var>int</var> b) { x=a; y=b; }
	<var>int</var> result() { <var>return</var> x+y;}
};

<var>int</var> main () {
  CDummy d;
  CAddition * padd;
  padd = (CAddition*) &amp;d;
  cout &lt;&lt; padd-&gt;result();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp> </samp></pre></td></tr></tbody></table></div>
<br>
<br>
The program declares a pointer to <tt>CAddition</tt>, but then it assigns to it a reference to an object of another incompatible type using explicit type-casting:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>&nbsp;</tt></td>
<td class="source"><pre><code>padd = (CAddition*) &amp;d;</code></pre></td></tr></tbody></table></div>
<br>
<br>
Traditional explicit type-casting allows to convert any pointer into
any other pointer type, independently of the types they point to. The
subsequent call to member <tt>result</tt> will produce either a run-time error or a unexpected result.<br>
<br>
In order to control these types of conversions between classes, we have four specific casting operators: <tt>dynamic_cast</tt>, <tt>reinterpret_cast</tt>, <tt>static_cast</tt> and <tt>const_cast</tt>. Their format is to follow the new type enclosed between angle-brackets (<tt>&lt;&gt;</tt>) and immediately after, the expression to be converted between parentheses.<br>
<br>
<tt>
dynamic_cast &lt;new_type&gt; (expression)<br>
reinterpret_cast &lt;new_type&gt; (expression)<br>
static_cast &lt;new_type&gt; (expression)<br>
const_cast &lt;new_type&gt; (expression)<br>
</tt>
<br>
The traditional type-casting equivalents to these expressions would be:<br>
 <br>
<tt>
(new_type) expression<br>
new_type (expression)<br>
</tt>
<br>
but each one with its own special characteristics:<br>
<br>
<h3>dynamic_cast</h3>
<br>
<tt>dynamic_cast</tt> can be used only with pointers and references to
objects. Its purpose is to ensure that the result of the type
conversion is a valid complete object of the requested class.<br>
<br>
Therefore, <tt>dynamic_cast</tt> is always successful when we cast a class to one of its base classes:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></tt></td>
<td class="source"><pre><code><var>class</var> CBase { };
<var>class</var> CDerived: <var>public</var> CBase { };

CBase b; CBase* pb;
CDerived d; CDerived* pd;

pb = <var>dynamic_cast</var>&lt;CBase*&gt;(&amp;d);     <cite>// ok: derived-to-base</cite>
pd = <var>dynamic_cast</var>&lt;CDerived*&gt;(&amp;b);  <cite>// wrong: base-to-derived </cite></code></pre></td></tr></tbody></table></div>
<br>
<br>
The second conversion in this piece of code would produce a compilation
error since base-to-derived conversions are not allowed with <tt>dynamic_cast</tt> unless the base class is polymorphic.<br>
<br>
When a class is polymorphic, <tt>dynamic_cast</tt> performs a special checking during runtime to ensure that the expression yields a valid complete object of the requested class:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></tt></td>
<td class="source"><pre><code><cite>// dynamic_cast</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;exception&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> CBase { <var>virtual</var> <var>void</var> dummy() {} };
<var>class</var> CDerived: <var>public</var> CBase { <var>int</var> a; };

<var>int</var> main () {
  <var>try</var> {
    CBase * pba = <var>new</var> CDerived;
    CBase * pbb = <var>new</var> CBase;
    CDerived * pd;

    pd = <var>dynamic_cast</var>&lt;CDerived*&gt;(pba);
    <var>if</var> (pd==0) cout &lt;&lt; <kbd>"Null pointer on first type-cast"</kbd> &lt;&lt; endl;

    pd = <var>dynamic_cast</var>&lt;CDerived*&gt;(pbb);
    <var>if</var> (pd==0) cout &lt;&lt; <kbd>"Null pointer on second type-cast"</kbd> &lt;&lt; endl;

  } <var>catch</var> (exception&amp; e) {cout &lt;&lt; <kbd>"Exception: "</kbd> &lt;&lt; e.what();}
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Null pointer on second type-cast</samp></pre></td></tr></tbody></table></div>
<br>
<br>
<table class="boxed"><tbody><tr><td>
<b>Compatibility note:</b> <tt>dynamic_cast</tt> requires the Run-Time
Type Information (RTTI) to keep track of dynamic types. Some compilers
support this feature as an option which is disabled by default. This
must be enabled for runtime type checking using <tt>dynamic_cast</tt> to work properly.<br>
</td></tr></tbody></table>
<br>
The code tries to perform two dynamic casts from pointer objects of type <tt>CBase*</tt> (<tt>pba</tt> and <tt>pbb</tt>) to a pointer object of type <tt>CDerived*</tt>, but only the first one is successful. Notice their respective initializations:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br></tt></td>
<td class="source"><pre><code>CBase * pba = <var>new</var> CDerived;
CBase * pbb = <var>new</var> CBase;</code></pre></td></tr></tbody></table></div>
<br>
<br>
Even though both are pointers of type <tt>CBase*</tt>, <tt>pba</tt> points to an object of type <tt>CDerived</tt>, while <tt>pbb</tt> points to an object of type <tt>CBase</tt>. Thus, when their respective type-castings are performed using <tt>dynamic_cast</tt>, <tt>pba</tt> is pointing to a full object of class <tt>CDerived</tt>, whereas <tt>pbb</tt> is pointing to an object of class <tt>CBase</tt>, which is an incomplete object of class <tt>CDerived</tt>.<br>
 <br>
When <tt>dynamic_cast</tt>
cannot cast a pointer because it is not a complete object of the
required class -as in the second conversion in the previous example- it
returns a null pointer to indicate the failure. If <tt>dynamic_cast</tt> is used to convert to a reference type and the conversion is not possible, an exception of type <tt>bad_cast</tt> is thrown instead.<br>
<br>
<tt>dynamic_cast</tt> can also cast null pointers even between pointers
to unrelated classes, and can also cast pointers of any type to void
pointers (<tt>void*</tt>).<br>
<br>
<h3>static_cast</h3>
<tt>static_cast</tt> can perform conversions between pointers to
related classes, not only from the derived class to its base, but also
from a base class to its derived. This ensures that at least the
classes are compatible if the proper object is converted, but no safety
check is performed during runtime to check if the object being
converted is in fact a full object of the destination type. Therefore,
it is up to the programmer to ensure that the conversion is safe. On
the other side, the overhead of the type-safety checks of <tt>dynamic_cast</tt> is avoided.<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br></tt></td>
<td class="source"><pre><code><var>class</var> CBase {};
<var>class</var> CDerived: <var>public</var> CBase {};
CBase * a = <var>new</var> CBase;
CDerived * b = <var>static_cast</var>&lt;CDerived*&gt;(a);</code></pre></td></tr></tbody></table></div>
<br>
<br>
This would be valid, although <tt>b</tt> would point to an incomplete object of the class and could lead to runtime errors if dereferenced.<br>
<br>
<tt>static_cast</tt> can also be used to perform any other non-pointer
conversion that could also be performed implicitly, like for example
standard conversion between fundamental types:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br></tt></td>
<td class="source"><pre><code><var>double</var> d=3.14159265;
<var>int</var> i = <var>static_cast</var>&lt;<var>int</var>&gt;(d); </code></pre></td></tr></tbody></table></div>
<br>
<br>
Or any conversion between classes with explicit constructors or operator functions as described in "implicit conversions" above.<br>
<br>
<h3>reinterpret_cast</h3>
<tt>reinterpret_cast</tt> converts any pointer type to any other
pointer type, even of unrelated classes. The operation result is a
simple binary copy of the value from one pointer to the other. All
pointer conversions are allowed: neither the content pointed nor the
pointer type itself is checked.<br>
<br>
It can also cast pointers to or from integer types. The format in which
this integer value represents a pointer is platform-specific. The only
guarantee is that a pointer cast to an integer type large enough to
fully contain it, is granted to be able to be cast back to a valid
pointer.<br>
<br>
The conversions that can be performed by <tt>reinterpret_cast</tt> but not by <tt>static_cast</tt>
have no specific uses in C++ are low-level operations, whose
interpretation results in code which is generally system-specific, and
thus non-portable. For example:<br>
<br>
<div class="auto"><table class="snippet"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br></tt></td>
<td class="source"><pre><code><var>class</var> A {};
<var>class</var> B {};
A * a = <var>new</var> A;
B * b = <var>reinterpret_cast</var>&lt;B*&gt;(a);</code></pre></td></tr></tbody></table></div>
<br>
<br>
This is valid C++ code, although it does not make much sense, since now
we have a pointer that points to an object of an incompatible class,
and thus dereferencing it is unsafe.<br>
<br>
<h3>const_cast</h3>
This type of casting manipulates the constness of an object, either to
be set or to be removed. For example, in order to pass a const argument
to a function that expects a non-constant parameter:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></tt></td>
<td class="source"><pre><code><cite>// const_cast</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> print (<var>char</var> * str)
{
  cout &lt;&lt; str &lt;&lt; endl;
}

<var>int</var> main () {
  <var>const</var> <var>char</var> * c = <kbd>"sample text"</kbd>;
  print ( <var>const_cast</var>&lt;<var>char</var> *&gt; (c) );
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>sample text</samp></pre></td></tr></tbody></table></div>
<br>
<br>
<h3>typeid</h3>
<tt>typeid</tt> allows to check the type of an expression: <br>
<br>
<tt>
typeid (expression)<br>
</tt>
<br>
This operator returns a reference to a constant object of type <tt>type_info</tt> that is defined in the standard header file <tt>&lt;typeinfo&gt;</tt>. This returned value can be compared with another one using operators <tt>==</tt> and <tt>!=</tt> or can serve to obtain a null-terminated character sequence representing the data type or class name by using its <tt>name()</tt> member.<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></tt></td>
<td class="source"><pre><code><cite>// typeid</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;typeinfo&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  <var>int</var> * a,b;
  a=0; b=0;
  <var>if</var> (<var>typeid</var>(a) != <var>typeid</var>(b))
  {
    cout &lt;&lt; <kbd>"a and b are of different types:\n"</kbd>;
    cout &lt;&lt; <kbd>"a is: "</kbd> &lt;&lt; <var>typeid</var>(a).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"b is: "</kbd> &lt;&lt; <var>typeid</var>(b).name() &lt;&lt; <kbd>'\n'</kbd>;
  }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>a and b are of different types:
a is: int *
b is: int  </samp></pre></td></tr></tbody></table></div>
<br>
<br>
When <tt>typeid</tt> is applied to classes <tt>typeid</tt> uses
the RTTI to keep track of the type of dynamic objects. When typeid is
applied to an expression whose type is a polymorphic class, the result
is the type of the most derived complete object:<br>
<br>
<div class="auto"><table class="split"><tbody><tr><td class="rownum"><tt>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></tt></td>
<td class="source"><pre><code><cite>// typeid, polymorphic class</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;typeinfo&gt;</dfn>
<dfn>#include &lt;exception&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> CBase { <var>virtual</var> <var>void</var> f(){} };
<var>class</var> CDerived : <var>public</var> CBase {};

<var>int</var> main () {
  <var>try</var> {
    CBase* a = <var>new</var> CBase;
    CBase* b = <var>new</var> CDerived;
    cout &lt;&lt; <kbd>"a is: "</kbd> &lt;&lt; <var>typeid</var>(a).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"b is: "</kbd> &lt;&lt; <var>typeid</var>(b).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"*a is: "</kbd> &lt;&lt; <var>typeid</var>(*a).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"*b is: "</kbd> &lt;&lt; <var>typeid</var>(*b).name() &lt;&lt; <kbd>'\n'</kbd>;
  } <var>catch</var> (exception&amp; e) { cout &lt;&lt; <kbd>"Exception: "</kbd> &lt;&lt; e.what() &lt;&lt; endl; }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>a is: class CBase *
b is: class CBase *
*a is: class CBase
*b is: class CDerived</samp></pre></td></tr></tbody></table></div>
<br>
<br>
<i>Note: The string returned by member <tt>name</tt> of <a href="http://www.cplusplus.com/type_info">type_info</a>
depends on the specific implementation of your compiler and library. It
is not necessarily a simple string with its typical type name, like in
the compiler used to produce this output.</i>
<br>
<br>
Notice how the type that <tt>typeid</tt> considers for pointers is the pointer type itself (both <tt>a</tt> and <tt>b</tt> are of type <tt>class CBase *</tt>). However, when <tt>typeid</tt> is applied to objects (like <tt>*a</tt> and <tt>*b</tt>) <tt>typeid</tt> yields their dynamic type (i.e. the type of their most derived complete object).<br>
<br>
If the type <tt>typeid</tt> evaluates is a pointer preceded by the dereference operator (<tt>*</tt>), and this pointer has a null value, <tt>typeid</tt> throws a <tt>bad_typeid</tt> exception.<br>
<br>
What our compiler returned in the calls <a href="http://www.cplusplus.com/type_info::name">type_info::name</a>
in the this example, our compiler generated names that are easily
understandable by humans, but this is not a requirement: a compiler may
just return any string.<br>
<table class="C_docPrevNext"><tbody><tr><td class="prev"><a href="http://www.cplusplus.com/doc/tutorial/exceptions/" rel="prev"><img src="Type%20Casting%20-%20C++%20Documentation_files/navigate_previous.gif" alt="Previous">Previous:<br><b>Exceptions</b></a></td><td class="index"><a href="http://www.cplusplus.com/doc/tutorial/" rel="index"><img src="Type%20Casting%20-%20C++%20Documentation_files/navigate_index.gif" alt="Index">Index</a></td><td class="next"><a href="http://www.cplusplus.com/doc/tutorial/preprocessor/" rel="next"><img src="Type%20Casting%20-%20C++%20Documentation_files/navigate_next.gif" alt="Next">Next:<br><b>Preprocessor directives</b></a></td></tr></tbody></table><div id="CH_bb"></div><script type="text/javascript">new doc_Page('CH_bb','/doc/item.cgi',22,0,0,32768);</script>
<p>

<script type="text/javascript"><!--
google_ad_client = "pub-7688470879129516";
google_ad_slot = "7973859818";
google_ad_width = 728;
google_ad_height = 90;
//-->
</script>
<script type="text/javascript" src="Type%20Casting%20-%20C++%20Documentation_files/show_ads.js">
</script><ins style="border: medium none ; margin: 0pt; padding: 0pt; display: inline-table; height: 90px; position: relative; visibility: visible; width: 728px;"><ins id="aswift_2_anchor" style="border: medium none ; margin: 0pt; padding: 0pt; display: block; height: 90px; position: relative; visibility: visible; width: 728px;"><iframe allowtransparency="true" hspace="0" marginwidth="0" marginheight="0" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){i+='.call';setTimeout(h,0)}else if(h.match){i+='.nav';w.location.replace(h)}s.log&amp;&amp;s.log.push(i)}" vspace="0" id="aswift_2" name="aswift_2" style="left: 0pt; position: absolute; top: 0pt;" width="728" frameborder="0" height="90" scrolling="no"></iframe></ins></ins>
</p></td></tr></tbody></table>
</div>
<div id="CH_footer">
	<a href="http://www.cplusplus.com/">Home page</a> | <a href="http://www.cplusplus.com/privacy.do">Privacy policy</a><br>© cplusplus.com, 2000-2011 - All rights reserved - <i>v2.9</i><br><a href="http://www.cplusplus.com/contact.do?referrer=http%3A%2F%2Fwww.cplusplus.com%2Fdoc%2Ftutorial%2Ftypecasting%2F">Spotted an error? contact us</a>
</div>

<script src="Type%20Casting%20-%20C++%20Documentation_files/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
onPrint.print();
var gso = new Session ('ssn29','rel29',14400,86400,1313153560);
_uacct = "UA-521783-1";
urchinTracker();
</script>
</body></html>